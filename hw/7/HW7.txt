CS220 Homework 7 Due Apr ??, 2016

Name: Rushil Kumar

For this week's homework, you will be given C code for a function, and the X86
assembler code associated with that C code.  Your job is to identify the lines
of X86 assembler associated with each line of C code.  Each line of the C code
is labeled with a letter, and each line of X86 code is labeled with a number.
For each line of C code (letter), specify the lines of X86 code associated with
that line of C code.  For example, here is the C code for the main function:

A	int main(int argc, char **argv) {
		enum colors color;
		int i;
B		for(i=1; i<argc; i++) {
C			int freq=atoi(argv[i]);
D			if (freq) {
E				color=getColor(freq);
F				printf("Color %s has frequency %d to %d THz\n",
					colorName(color),minFreq(color),maxFreq(color));
			}
		}
G		return 0;
	}
	
And here is the associated X86 code...

1	main:	pushl	%ebp
2		movl	%esp, %ebp
3		pushl	%esi
4		pushl	%ebx
5		andl	$-16, %esp
6		subl	$32, %esp
7		movl	$1, 28(%esp)
8		jmp	.L2
9	.L4:	movl	28(%esp), %eax
10		leal	0(,%eax,4), %edx
11		movl	12(%ebp), %eax
12		addl	%edx, %eax
13		movl	(%eax), %eax
14		movl	%eax, (%esp)
15		call	atoi
16		movl	%eax, 24(%esp)
17		cmpl	$0, 24(%esp)
18		je	.L3
19		movl	24(%esp), %eax
20		movl	%eax, (%esp)
21		call	getColor
22		movl	%eax, 20(%esp)
23		movl	20(%esp), %eax
24		movl	%eax, (%esp)
25		call	maxFreq
26		movl	%eax, %esi
27		movl	20(%esp), %eax
28		movl	%eax, (%esp)
29		call	minFreq
30		movl	%eax, %ebx
31		movl	20(%esp), %eax
32		movl	%eax, (%esp)
33		call	colorName
34		movl	%esi, 12(%esp)
35		movl	%ebx, 8(%esp)
36		movl	%eax, 4(%esp)
37		movl	$.LC0, (%esp)
38		call	printf
39	.L3:	addl	$1, 28(%esp)
40	.L2:	movl	28(%esp), %eax
41		cmpl	8(%ebp), %eax
42		jl	.L4
43		movl	$0, %eax
44		leal	-8(%ebp), %esp
45		popl	%ebx
46		popl	%esi
47		popl	%ebp
48		ret

The correct answer for the main function is as follows:

	A : 1 - 6
	B : 7 - 8, 39-42
	C : 9-16
	D : 17-18
	E : 19-22
	F : 23-38
	G : 42-48
	
1. Figure out the correlation for the "minFreq" function...

C code:

A	int minFreq(enum colors color) {
B		assert(color>=0);
C		if (color==uv) return 1000000;
D		assert(color<uv);
E		return maxw[color+1];
	}
	
X86 assembler:

1	minFreq: pushl	%ebp
2		movl	%esp, %ebp
3		subl	$24, %esp
4		cmpl	$6, 8(%ebp)
5		jne	.L7
6		movl	$1000000, %eax
7		jmp	.L8
8	.L7:	cmpl	$5, 8(%ebp)
9		jbe	.L9
10		movl	$__PRETTY_FUNCTION__.2357, 12(%esp)
11		movl	$31, 8(%esp)
12		movl	$.LC1, 4(%esp)
13		movl	$.LC2, (%esp)
14		call	__assert_fail
15	.L9:	movl	8(%ebp), %eax
16		addl	$1, %eax
17		movl	maxw(,%eax,4), %eax
18	.L8:	leave
19		ret

Warning... in this case, the two "return" statements share some X86 code.  
Associate the shared X86 code with both of the "return" statements in C.  Aslo,
the compiler has done some optimization on our original code, so be careful.

Correlation:

	A : 1-3
	B : 8-14
	C : 4-7, 18-19
	D : 8-14
	E : 15-19
	
	
2. Figure out the correlation for the "getColor" function...

C code:

A	enum colors getColor(int freq) {
B		if (freq>maxw[0]) return uv;
C		int j=0;
D		while(maxw[j]>freq) { j++; }
E		if (j>uv) return uv;
F		return (enum colors)(j-1);
	}
	
X86 assembler:

1	getColor: pushl	%ebp
2		movl	%esp, %ebp
3		subl	$16, %esp
4		movl	maxw, %eax
5		cmpl	8(%ebp), %eax
6		jge	.L14
7		movl	$6, %eax
8		jmp	.L15
9	.L14:	movl	$0, -4(%ebp)
10		jmp	.L16
11	.L17:	addl	$1, -4(%ebp)
12	.L16:	movl	-4(%ebp), %eax
13		movl	maxw(,%eax,4), %eax
14		cmpl	8(%ebp), %eax
15		jg	.L17
16		cmpl	$6, -4(%ebp)
17		jle	.L18
18		movl	$6, %eax
19		jmp	.L15
20	.L18:	movl	-4(%ebp), %eax
21		subl	$1, %eax
22	.L15:	leave
23		ret	

Correlation:

	A : 1-3
	B : 4-8, 22-23
	C : 9
	D : 10-15
	E : 16-19, 22-23
	F : 20-23
	
3. Figure out the correlation for the "colorName" function...

C code:	

A	char * colorName(enum colors color) {
B		switch(color) {
C			case red: return "red";
D			case orange: return "orange";
E			case yellow: return "yellow";
F			case green: return "green";
G			case blue: return "blue";
H			case violet: return "violet";
I			default: return "invisible";
		}
	}

X86 assembler:

1	.LC4: 	.string	"red"
2	.LC5:	.string	"orange"
3	.LC6:	.string	"yellow"
4	.LC7:	.string	"green"
5	.LC8:	.string	"blue"
6	.LC9:	.string	"violet"
7	.LC10:	.string	"invisible"
8	colorName: pushl	%ebp
9		movl	%esp, %ebp
10		cmpl	$5, 8(%ebp)
11		ja	.L20
12		movl	8(%ebp), %eax
13		sall	$2, %eax
14		addl	$.L27, %eax
15		movl	(%eax), %eax
16		jmp	*%eax
		.align 4
17	.L27:	.long	.L21
18		.long	.L22
19		.long	.L23
20		.long	.L24
21		.long	.L25
22		.long	.L26
23	.L21:	movl	$.LC4, %eax
24		jmp	.L28
25	.L22:	movl	$.LC5, %eax
26		jmp	.L28
27	.L23:	movl	$.LC6, %eax
28		jmp	.L28
29	.L24:	movl	$.LC7, %eax
30		jmp	.L28
31	.L25:	movl	$.LC8, %eax
32		jmp	.L28
33	.L26:	movl	$.LC9, %eax
34		jmp	.L28
35	.L20:	movl	$.LC10, %eax
36	.L28:	popl	%ebp
37		ret	

Note... include the data associated with each line as well as the instructions 
in your correlation. For instance, the jump table is generated by the switch
statement.

Correlation:

	A : 8-9
	B : 10-16
	C : 1, 17, 23-24, 36-37
	D : 2, 18, 25-26, 36-37
	E : 3, 19, 27-28, 36-37
	F : 4, 20, 29-30, 36-37
	G : 5, 21, 31-32, 36-37
	H : 6, 22, 33-34, 36-37
	I : 7, 11, 35-37
